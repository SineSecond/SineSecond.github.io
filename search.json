[{"title":"P8398","url":"/2025/11/21/P8398/","content":"感谢我的御用纯情娇羞可爱内向小男娘 @songhy_QWQ 启发我洛谷是有最优解的所以我去抢了个最优解。\n首先，由于我们的三角形必须过圆心，容易发现在前两个点确定的情况下，第三个点必须在前两个的的对称点之间。如图，这里红点是我们选定的第一个点，蓝点是选定的第二个点，则第三个点只能选在黄线上（不含两端）。\n\n注意，因为我的写法是红蓝黄三个点顺时针排列，所以这里蓝点距离红点最多 $\\lfloor \\frac{c}{2} \\rfloor$。至此，我们可以写出第一个暴力代码。\nfor (itn i = 1; i &lt;= c; i++)   for (int j = i + 1; j &lt; (i + ((c + 1) &gt;&gt; 1)); j++)     for (int k = i + (c &gt;&gt; 1) + 1; k &lt; (j + ((c + 1) &gt;&gt; 1)); k++)       ans += cnt[i] * cnt[j] * cnt[k];\n\n（$cnt_i$：在 $i$ 的位置有几个可以选择的点）\n时间复杂度 $O(n^3)$，考虑优化，观察到第三维枚举 $k$ 其实是在对 $cnt$ 进行区间求和，考虑使用前缀和压掉第三维。\nfor (int i = 1; i &lt;= (c &lt;&lt; 1); i++) s[i] = cnt[i] + s[i - 1];for (itn i = 1; i &lt;= c; i++)   for (int j = i + 1; j &lt; (i + ((c + 1) &gt;&gt; 1)); j++)     ans += cnt[i] * cnt[j] * (s[j + ((c + 1) &gt;&gt; 1) - 1] - s[i + (c &gt;&gt; 1)]);\n\n时间复杂度 $O(n^2)$ 考虑继续优化，先把柿子拆开。\nans += cnt[i] * cnt[j] * s[j + ((c + 1) &gt;&gt; 1) - 1];ans -= cnt[i] * s[i + (c &gt;&gt; 1)] * cnt[j];\n\n观察到下面这个柿子也可以用前缀和解决，那么最后的问题就是处理 cnt[j] * s[j + ((c + 1) &gt;&gt; 1) - 1]。直接对 $cnt_j\\times s_{j+(\\lceil c&#x2F;2 \\rceil)-1}$ 求前缀和即可。放下代码\n#include &lt;bits/stdc++.h&gt;#define double long double#define pii pair&lt;int, int&gt;#define fi first#define se second#define gc getchar#define el cout &lt;&lt; &quot;\\n&quot;#define ls (p &lt;&lt; 1)#define rs (p &lt;&lt; 1 | 1)#define ll long long#define int long long#define itn int#define lowbit(x) ((x) &amp; (-x))using namespace std;const int N = 1000010;int T = 1, n, c, x, ans, s[N &lt;&lt; 1], f[N &lt;&lt; 1], cnt[N &lt;&lt; 1];void init() &#123;&#125;void solve() &#123;  init();  cin &gt;&gt; n &gt;&gt; c;  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; x;    x++;    cnt[x]++;  &#125;  for (itn i = c + 1; i &lt;= (c &lt;&lt; 1); i++) cnt[i] = cnt[i - c];  for (int i = 1; i &lt;= (c &lt;&lt; 1); i++) s[i] = cnt[i] + s[i - 1];  for (int i = 1; i &lt;= ((c * 3) &gt;&gt; 1); i++)    f[i] = f[i - 1] + cnt[i] * s[i + ((c + 1) &gt;&gt; 1) - 1];  for (itn i = 1; i &lt;= c; i++)    ans += cnt[i] * (f[i + ((c + 1) &gt;&gt; 1) - 1] - f[i] -                     s[i + (c &gt;&gt; 1)] * (s[i + ((c + 1) &gt;&gt; 1) - 1] - s[i]));  cout &lt;&lt; ans / 3;&#125;signed main() &#123;  ios::sync_with_stdio(0);  cin.tie(0);  // freopen(&quot;文件名.in&quot;, &quot;r&quot;, stdin);  // freopen(&quot;文件名.out&quot;, &quot;w&quot;, stdout);  // cin &gt;&gt; T;  while (T--) solve();  return 0;&#125;\n\n注意：\n\n因为这道题是环形的，所以要把原数组复制一遍，周长乘二。\n因为一个三角形会由三个顶点分别作为红蓝黄计算一次，所以答案要除以三。\n\n","categories":["题解"],"tags":["OI"]},{"title":"Hello World","url":"/2025/11/21/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"}]